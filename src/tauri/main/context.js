export function createTauriMainContext({ invoke, convertFileSrc }) {
    let userDirectories = null;
    let characterCache = [];
    let characterByAvatar = new Map();
    let characterByDisplayName = new Map();
    let characterById = new Map();

    async function initialize() {
        await loadUserDirectories();
        installAssetPathHelpers();
    }

    async function loadUserDirectories() {
        let lastError = null;

        for (let attempt = 0; attempt < 40; attempt += 1) {
            try {
                userDirectories = await invoke('get_default_user_directory');
                return;
            } catch (error) {
                lastError = error;
                await sleep(250);
            }
        }

        console.warn('Could not load default user directories:', lastError);
    }

    function installAssetPathHelpers() {
        window.__TAURITAVERN_THUMBNAIL__ = (type, file, useTimestamp = false) => {
            const filePath = resolveAssetPath(type, file);

            if (filePath) {
                const assetUrl = toAssetUrl(filePath);
                if (assetUrl) {
                    return `${assetUrl}${useTimestamp ? `?t=${Date.now()}` : ''}`;
                }
            }

            return `/thumbnail?type=${encodeURIComponent(type)}&file=${encodeURIComponent(file)}${useTimestamp ? `&t=${Date.now()}` : ''}`;
        };

        window.__TAURITAVERN_BACKGROUND_PATH__ = (file) => {
            const filePath = resolveAssetPath('bg', file);
            const assetUrl = filePath ? toAssetUrl(filePath) : null;
            return assetUrl || `backgrounds/${encodeURIComponent(file)}`;
        };

        window.__TAURITAVERN_PERSONA_PATH__ = (file) => {
            const filePath = resolveAssetPath('persona', file);
            const assetUrl = filePath ? toAssetUrl(filePath) : null;
            return assetUrl || `User Avatars/${file}`;
        };
    }

    function resolveAssetPath(type, file) {
        if (!userDirectories || !file) {
            return null;
        }

        const cleanFile = sanitizeRelativePath(file);
        if (!cleanFile) {
            return null;
        }

        switch (type) {
            case 'avatar':
                return joinPath(userDirectories.characters, cleanFile);
            case 'persona':
                return joinPath(userDirectories.avatars, cleanFile);
            case 'bg':
                return joinPath(userDirectories.backgrounds, cleanFile);
            default:
                return null;
        }
    }

    function toAssetUrl(path) {
        if (!path) {
            return null;
        }

        if (typeof convertFileSrc === 'function') {
            try {
                // In Tauri WebView, file:// resources are generally blocked for img/src.
                // Always use the asset protocol URL generated by convertFileSrc.
                return convertFileSrc(path, 'asset');
            } catch (error) {
                console.warn('convertFileSrc failed:', error);
            }
        }

        return null;
    }

    function joinPath(base, child) {
        if (!base) {
            return null;
        }

        const normalizedBase = String(base).replace(/[\\/]+$/, '');
        const normalizedChild = String(child).replace(/^[\\/]+/, '');
        const separator = normalizedBase.includes('\\') ? '\\' : '/';

        return `${normalizedBase}${separator}${normalizedChild.replace(/[\\/]+/g, separator)}`;
    }

    function sanitizeRelativePath(file) {
        const decoded = decodeURIComponent(String(file));
        const normalized = decoded.replace(/[\\/]+/g, '/').replace(/^\/+/, '');

        if (!normalized || normalized.includes('..')) {
            return null;
        }

        return normalized;
    }

    async function safeInvoke(command, args = {}) {
        for (let attempt = 0; attempt < 20; attempt += 1) {
            try {
                return await invoke(command, args);
            } catch (error) {
                const message = error?.message || error?.toString?.() || `Command failed: ${command}`;
                if (attempt < 19 && shouldRetryInvoke(message)) {
                    await sleep(200);
                    continue;
                }
                throw new Error(message);
            }
        }
    }

    function shouldRetryInvoke(message) {
        const normalized = String(message || '').toLowerCase();
        return (
            (normalized.includes('state') && normalized.includes('not managed')) ||
            normalized.includes('invoke is unavailable')
        );
    }

    function normalizeCharacter(character) {
        if (!character || typeof character !== 'object') {
            return character;
        }

        const extensions = normalizeExtensions(character.extensions);

        if (!Object.prototype.hasOwnProperty.call(extensions, 'talkativeness')) {
            extensions.talkativeness = Number(character.talkativeness ?? 0.5);
        }

        if (!Object.prototype.hasOwnProperty.call(extensions, 'fav')) {
            extensions.fav = Boolean(character.fav);
        }

        const characterBook = Object.prototype.hasOwnProperty.call(character, 'character_book')
            ? character.character_book
            : character?.data?.character_book;

        const name = pickCharacterTextValue(character.name, character?.data?.name);
        const description = pickCharacterTextValue(character.description, character?.data?.description);
        const personality = pickCharacterTextValue(character.personality, character?.data?.personality);
        const scenario = pickCharacterTextValue(character.scenario, character?.data?.scenario);
        const firstMes = pickCharacterTextValue(character.first_mes, character?.data?.first_mes);
        const mesExample = pickCharacterTextValue(character.mes_example, character?.data?.mes_example);
        const creator = pickCharacterTextValue(character.creator, character?.data?.creator);
        const creatorNotes = pickCharacterTextValue(character.creator_notes, character?.data?.creator_notes);
        const characterVersion = pickCharacterTextValue(character.character_version, character?.data?.character_version);
        const systemPrompt = pickCharacterTextValue(character.system_prompt, character?.data?.system_prompt);
        const postHistoryInstructions = pickCharacterTextValue(
            character.post_history_instructions,
            character?.data?.post_history_instructions,
        );

        const data = {
            name,
            description,
            personality,
            scenario,
            first_mes: firstMes,
            mes_example: mesExample,
            creator,
            creator_notes: creatorNotes,
            character_version: characterVersion,
            system_prompt: systemPrompt,
            post_history_instructions: postHistoryInstructions,
            tags: Array.isArray(character.tags) ? character.tags : [],
            alternate_greetings: Array.isArray(character.alternate_greetings) ? character.alternate_greetings : [],
            character_book: characterBook ?? null,
            extensions,
        };

        return {
            ...character,
            name,
            description,
            personality,
            scenario,
            first_mes: firstMes,
            mes_example: mesExample,
            creator,
            creator_notes: creatorNotes,
            character_version: characterVersion,
            system_prompt: systemPrompt,
            post_history_instructions: postHistoryInstructions,
            creatorcomment: creatorNotes,
            data,
            shallow: false,
        };
    }

    function pickCharacterTextValue(...values) {
        for (const value of values) {
            if (typeof value === 'string' && value.length > 0) {
                return value;
            }
        }

        return '';
    }

    function normalizeExtensions(input) {
        if (!input || typeof input !== 'object' || Array.isArray(input)) {
            return {};
        }

        return { ...input };
    }

    function updateCharacterCache(characters) {
        characterCache = Array.isArray(characters) ? characters : [];
        characterByAvatar = new Map();
        characterByDisplayName = new Map();
        characterById = new Map();

        for (const character of characterCache) {
            if (character?.avatar) {
                const rawAvatar = String(character.avatar);
                characterByAvatar.set(rawAvatar, character);

                const normalizedAvatar = normalizeAvatarFileName(rawAvatar);
                if (normalizedAvatar) {
                    characterByAvatar.set(normalizedAvatar, character);
                }
            }

            if (character?.name) {
                characterByDisplayName.set(String(character.name), character);
            }

            const characterId = getCharacterId(character);
            if (characterId) {
                characterById.set(characterId, character);
            }
        }
    }

    async function getAllCharacters({ shallow = false, forceRefresh = false } = {}) {
        if (!forceRefresh && characterCache.length > 0) {
            return characterCache;
        }

        const characters = await safeInvoke('get_all_characters', { shallow });
        const normalized = Array.isArray(characters) ? characters.map(normalizeCharacter) : [];
        updateCharacterCache(normalized);
        return normalized;
    }

    async function resolveCharacterId({ avatar, fallbackName } = {}) {
        const avatarInternalId = getAvatarInternalId(avatar);
        const avatarFileName = normalizeAvatarFileName(avatar);

        const resolveFromCache = () => {
            if (avatar !== undefined && avatar !== null) {
                const fromRawAvatar = characterByAvatar.get(String(avatar));
                const fromRawAvatarId = getCharacterId(fromRawAvatar);
                if (fromRawAvatarId) {
                    return fromRawAvatarId;
                }
            }

            if (avatarFileName) {
                const fromFileName = characterByAvatar.get(avatarFileName);
                const fromFileNameId = getCharacterId(fromFileName);
                if (fromFileNameId) {
                    return fromFileNameId;
                }
            }

            if (avatarInternalId) {
                const fromInternalId = characterById.get(avatarInternalId);
                const fromInternalIdValue = getCharacterId(fromInternalId);
                if (fromInternalIdValue) {
                    return fromInternalIdValue;
                }
            }

            return null;
        };

        if (avatarInternalId || avatarFileName) {
            const cached = resolveFromCache();
            if (cached) {
                return cached;
            }

            await getAllCharacters({ shallow: false });
            const refreshed = resolveFromCache();
            if (refreshed) {
                return refreshed;
            }

            // Follow SillyTavern behavior: avatar stem defines chat directory key.
            if (avatarInternalId) {
                return avatarInternalId;
            }
        }

        const fallback = String(fallbackName || '').trim();
        if (!fallback) {
            return null;
        }

        const cachedByName = characterByDisplayName.get(fallback);
        const cachedByNameId = getCharacterId(cachedByName);
        if (cachedByNameId) {
            return cachedByNameId;
        }

        const cachedByInternalId = characterById.get(fallback);
        const cachedByInternalIdValue = getCharacterId(cachedByInternalId);
        if (cachedByInternalIdValue) {
            return cachedByInternalIdValue;
        }

        await getAllCharacters({ shallow: false });
        const refreshedByName = characterByDisplayName.get(fallback);
        const refreshedByNameId = getCharacterId(refreshedByName);
        if (refreshedByNameId) {
            return refreshedByNameId;
        }

        const refreshedByInternalId = characterById.get(fallback);
        const refreshedByInternalIdValue = getCharacterId(refreshedByInternalId);
        if (refreshedByInternalIdValue) {
            return refreshedByInternalIdValue;
        }

        return fallback;
    }

    function normalizeAvatarFileName(avatar) {
        if (avatar === null || avatar === undefined) {
            return null;
        }

        let value = String(avatar).trim();
        if (!value) {
            return null;
        }

        if (value.includes('?')) {
            try {
                const parsed = new URL(value, 'http://localhost');
                value = parsed.searchParams.get('file') || parsed.pathname || value;
            } catch {
                // Keep original value when URL parsing fails.
            }
        }

        try {
            value = decodeURIComponent(value);
        } catch {
            // Keep original value when decodeURIComponent fails.
        }

        value = value.split('?')[0].split('#')[0];
        if (!value) {
            return null;
        }

        const normalized = value.replace(/[\\/]+/g, '/');
        const fileName = normalized.split('/').pop();
        return fileName || null;
    }

    function getAvatarInternalId(avatar) {
        const fileName = normalizeAvatarFileName(avatar);
        if (!fileName) {
            return null;
        }

        return fileName.replace(/\.[^/.]+$/, '') || null;
    }

    function getCharacterId(character) {
        if (!character || typeof character !== 'object') {
            return null;
        }

        const fromAvatar = getAvatarInternalId(character.avatar);
        if (fromAvatar) {
            return fromAvatar;
        }

        if (character.name) {
            return String(character.name);
        }

        return null;
    }

    async function getSingleCharacter(body) {
        const explicitName = body?.name || body?.ch_name;
        const avatar = body?.avatar_url || body?.avatar;
        const characterId = await resolveCharacterId({ avatar, fallbackName: explicitName });

        if (!characterId) {
            return null;
        }

        const character = await safeInvoke('get_character', { name: characterId });
        const normalized = normalizeCharacter(character);
        if (normalized?.avatar) {
            characterByAvatar.set(String(normalized.avatar), normalized);
        }
        if (normalized?.name) {
            characterByDisplayName.set(String(normalized.name), normalized);
        }
        const normalizedCharacterId = getCharacterId(normalized);
        if (normalizedCharacterId) {
            characterById.set(normalizedCharacterId, normalized);
        }
        return normalized;
    }

    function ensureJsonl(fileName) {
        const value = String(fileName || '');
        if (!value) {
            return value;
        }

        return value.endsWith('.jsonl') ? value : `${value}.jsonl`;
    }

    function stripJsonl(fileName) {
        const value = String(fileName || '').trim();
        if (!value) {
            return '';
        }

        return value.replace(/\.jsonl$/i, '');
    }

    function toFrontendChat(chatDto) {
        const messages = Array.isArray(chatDto?.messages)
            ? chatDto.messages.map((message) => ({
                name: message.name,
                is_user: Boolean(message.is_user),
                is_system: Boolean(message.is_system),
                send_date: message.send_date,
                mes: message.mes,
                extra: message.extra || {},
            }))
            : [];

        const header = {
            user_name: chatDto?.user_name || 'User',
            character_name: chatDto?.character_name || '',
            create_date: chatDto?.create_date || '',
            chat_metadata: {
                chat_id_hash: Number(chatDto?.chat_id || 0),
            },
        };

        return [header, ...messages];
    }

    function formatFileSize(value) {
        const size = Number(value || 0);
        if (!Number.isFinite(size) || size <= 0) {
            return '0 B';
        }

        const units = ['B', 'KB', 'MB', 'GB'];
        let unitIndex = 0;
        let result = size;

        while (result >= 1024 && unitIndex < units.length - 1) {
            result /= 1024;
            unitIndex += 1;
        }

        return `${result.toFixed(result >= 10 ? 0 : 1)} ${units[unitIndex]}`;
    }

    function parseTimestamp(sendDate) {
        const parsed = Date.parse(String(sendDate || ''));
        return Number.isFinite(parsed) ? parsed : Date.now();
    }

    function exportChatAsText(frontendChat) {
        const lines = frontendChat.slice(1).map((message) => {
            const role = message.is_system ? 'System' : message.name || (message.is_user ? 'User' : 'Assistant');
            return `${role}: ${message.mes || ''}`;
        });

        return lines.join('\n\n');
    }

    function exportChatAsJsonl(frontendChat) {
        return frontendChat.map((item) => JSON.stringify(item)).join('\n');
    }

    function findAvatarByCharacterId(characterId) {
        const key = String(characterId || '').trim();
        if (!key) {
            return '';
        }

        const byDisplayName = characterByDisplayName.get(key);
        if (byDisplayName?.avatar) {
            return byDisplayName.avatar;
        }

        const byInternalId = characterById.get(key);
        if (byInternalId?.avatar) {
            return byInternalId.avatar;
        }

        const normalizedAvatar = normalizeAvatarFileName(key);
        if (normalizedAvatar) {
            const byAvatar = characterByAvatar.get(normalizedAvatar);
            if (byAvatar?.avatar) {
                return byAvatar.avatar;
            }

            if (normalizedAvatar.toLowerCase().endsWith('.png')) {
                return normalizedAvatar;
            }

            const pngName = `${normalizedAvatar}.png`;
            const byPng = characterByAvatar.get(pngName);
            if (byPng?.avatar) {
                return byPng.avatar;
            }

            return pngName;
        }

        return '';
    }

    async function uniqueCharacterName(baseName) {
        await getAllCharacters({ shallow: false });

        if (!characterByDisplayName.has(baseName)) {
            return baseName;
        }

        let index = 2;
        while (characterByDisplayName.has(`${baseName} ${index}`)) {
            index += 1;
        }

        return `${baseName} ${index}`;
    }

    function boolFromForm(formData, key) {
        const raw = formData.get(key);
        if (raw === null || raw === undefined) {
            return false;
        }

        const value = String(raw).trim().toLowerCase();
        return value === 'true' || value === '1' || value === 'on' || value === 'yes';
    }

    function numberFromForm(formData, key, fallback) {
        const raw = formData.get(key);
        const value = Number(raw);
        return Number.isFinite(value) ? value : fallback;
    }

    function stringFromForm(formData, key, fallback = '') {
        const raw = formData.get(key);
        if (raw === null || raw === undefined) {
            return fallback;
        }

        return String(raw);
    }

    function splitTags(tagsRaw) {
        if (Array.isArray(tagsRaw)) {
            return tagsRaw.map((tag) => String(tag).trim()).filter(Boolean);
        }

        if (typeof tagsRaw === 'string') {
            return tagsRaw.split(',').map((tag) => tag.trim()).filter(Boolean);
        }

        return [];
    }

    function parseJsonSafe(value, fallback = {}) {
        if (typeof value !== 'string' || !value.trim()) {
            return fallback;
        }

        try {
            return JSON.parse(value);
        } catch {
            return fallback;
        }
    }

    function buildCharacterExtensions(formData) {
        const extensions = parseJsonSafe(stringFromForm(formData, 'extensions', ''), {});

        const world = stringFromForm(formData, 'world', '').trim();
        if (world) {
            extensions.world = world;
        }

        const depthPrompt = stringFromForm(formData, 'depth_prompt_prompt', '').trim();
        if (depthPrompt) {
            extensions.depth_prompt = {
                prompt: depthPrompt,
                depth: numberFromForm(formData, 'depth_prompt_depth', 4),
                role: stringFromForm(formData, 'depth_prompt_role', 'system'),
            };
        }

        extensions.talkativeness = numberFromForm(formData, 'talkativeness', 0.5);
        extensions.fav = boolFromForm(formData, 'fav');

        return extensions;
    }

    function formDataToCreateCharacterDto(formData) {
        return {
            name: stringFromForm(formData, 'ch_name', '').trim(),
            description: stringFromForm(formData, 'description', ''),
            personality: stringFromForm(formData, 'personality', ''),
            scenario: stringFromForm(formData, 'scenario', ''),
            first_mes: stringFromForm(formData, 'first_mes', ''),
            mes_example: stringFromForm(formData, 'mes_example', ''),
            creator: stringFromForm(formData, 'creator', ''),
            creator_notes: stringFromForm(formData, 'creator_notes', ''),
            character_version: stringFromForm(formData, 'character_version', ''),
            tags: splitTags(stringFromForm(formData, 'tags', '')),
            talkativeness: numberFromForm(formData, 'talkativeness', 0.5),
            fav: boolFromForm(formData, 'fav'),
            alternate_greetings: formData.getAll('alternate_greetings').map((item) => String(item)).filter(Boolean),
            system_prompt: stringFromForm(formData, 'system_prompt', ''),
            post_history_instructions: stringFromForm(formData, 'post_history_instructions', ''),
            extensions: buildCharacterExtensions(formData),
        };
    }

    function formDataToUpdateCharacterDto(formData) {
        const dto = formDataToCreateCharacterDto(formData);
        const chat = stringFromForm(formData, 'chat', '').trim();

        return {
            name: dto.name,
            chat: chat || undefined,
            description: dto.description,
            personality: dto.personality,
            scenario: dto.scenario,
            first_mes: dto.first_mes,
            mes_example: dto.mes_example,
            creator: dto.creator,
            creator_notes: dto.creator_notes,
            character_version: dto.character_version,
            tags: dto.tags,
            talkativeness: dto.talkativeness,
            fav: dto.fav,
            alternate_greetings: dto.alternate_greetings,
            system_prompt: dto.system_prompt,
            post_history_instructions: dto.post_history_instructions,
            extensions: dto.extensions,
        };
    }

    async function createCharacterFromForm(formData, requestUrl) {
        const dto = formDataToCreateCharacterDto(formData);
        const crop = parseCropParam(requestUrl);
        const file = formData.get('avatar');

        if (file instanceof Blob && file.size > 0) {
            const fileInfo = await materializeUploadFile(file, {
                preferredName: file.name,
            });
            if (!fileInfo?.filePath) {
                const reason = fileInfo?.error ? `: ${fileInfo.error}` : '';
                throw new Error(`Unable to access avatar file path${reason}`);
            }

            try {
                return await safeInvoke('create_character_with_avatar', {
                    dto: {
                        character: dto,
                        avatar_path: fileInfo.filePath,
                        crop,
                    },
                });
            } finally {
                await fileInfo.cleanup?.();
            }
        }

        return safeInvoke('create_character', { dto });
    }

    async function editCharacterFromForm(formData, requestUrl) {
        const avatar = stringFromForm(formData, 'avatar_url', '');
        const fallbackName = stringFromForm(formData, 'ch_name', '');
        const originalCharacterId = await resolveCharacterId({ avatar, fallbackName });

        if (!originalCharacterId) {
            throw new Error('Character not found for edit');
        }

        const dto = formDataToUpdateCharacterDto(formData);
        await safeInvoke('update_character', { name: originalCharacterId, dto });

        const file = formData.get('avatar');
        if (file instanceof Blob && file.size > 0) {
            const crop = parseCropParam(requestUrl);
            const fileInfo = await materializeUploadFile(file, {
                preferredName: file.name,
            });

            if (!fileInfo?.filePath) {
                const reason = fileInfo?.error ? `: ${fileInfo.error}` : '';
                throw new Error(`Unable to access avatar file path${reason}`);
            }

            try {
                await safeInvoke('update_avatar', {
                    dto: {
                        name: dto.name || originalCharacterId,
                        avatar_path: fileInfo.filePath,
                        crop,
                    },
                });
            } finally {
                await fileInfo.cleanup?.();
            }
        }
    }

    function parseCropParam(url) {
        const raw = url.searchParams.get('crop');
        if (!raw) {
            return null;
        }

        try {
            return JSON.parse(raw);
        } catch {
            return null;
        }
    }

    function pickCharacterUpdateFields(payload) {
        const dto = {};
        const keys = [
            'name',
            'chat',
            'description',
            'personality',
            'scenario',
            'first_mes',
            'mes_example',
            'creator',
            'creator_notes',
            'character_version',
            'tags',
            'talkativeness',
            'fav',
            'alternate_greetings',
            'system_prompt',
            'post_history_instructions',
            'extensions',
        ];

        for (const key of keys) {
            if (Object.prototype.hasOwnProperty.call(payload, key)) {
                dto[key] = payload[key];
            }
        }

        return dto;
    }

    async function uploadAvatarFromForm(formData, requestUrl) {
        const file = formData.get('avatar');
        if (!(file instanceof Blob)) {
            throw new Error('No avatar file provided');
        }

        const overwriteNameRaw = formData.get('overwrite_name');
        const overwriteName = overwriteNameRaw ? String(overwriteNameRaw) : null;
        const crop = parseCropParam(requestUrl);

        const fileInfo = await materializeUploadFile(file, {
            preferredName: file.name,
        });
        if (!fileInfo?.filePath) {
            const reason = fileInfo?.error ? `: ${fileInfo.error}` : '';
            throw new Error(`Unable to access avatar file path${reason}`);
        }

        try {
            return await safeInvoke('upload_avatar', {
                file_path: fileInfo.filePath,
                overwrite_name: overwriteName,
                crop: crop ? JSON.stringify(crop) : null,
            });
        } finally {
            await fileInfo.cleanup?.();
        }
    }

    async function materializeUploadFile(file, { preferredName = '', preferredExtension = '' } = {}) {
        if (!(file instanceof Blob)) {
            return null;
        }

        const directPath = extractNativeFilePath(file);
        if (directPath) {
            return { filePath: directPath };
        }

        const tauri = window.__TAURI__;
        const pathApi = tauri?.path;
        const invokeApi = tauri?.core?.invoke;
        if (typeof pathApi?.tempDir !== 'function' || typeof pathApi?.join !== 'function') {
            return {
                filePath: '',
                error: 'Tauri path API is unavailable',
            };
        }

        if (typeof invokeApi !== 'function') {
            return {
                filePath: '',
                error: 'Tauri invoke API is unavailable',
            };
        }

        const extension = resolveUploadExtension({
            preferredExtension,
            preferredName,
            sourceName: file.name,
        });
        const fileName = `tauritavern-upload-${Date.now()}-${Math.random().toString(16).slice(2)}.${extension}`;
        const data = new Uint8Array(await file.arrayBuffer());

        try {
            const tempDir = await pathApi.tempDir();
            const filePath = await pathApi.join(tempDir, fileName);
            await writeTempUploadFile(filePath, data, invokeApi);

            return {
                filePath,
                cleanup: async () => {
                    try {
                        await removeTempUploadFile(filePath, invokeApi);
                    } catch {
                        // noop
                    }
                },
            };
        } catch (error) {
            console.warn('Tauri temp file write failed:', error);
            return {
                filePath: '',
                error: error?.message || 'Failed to materialize upload file',
            };
        }
    }

    async function writeTempUploadFile(filePath, data, invokeApi) {
        await invokeApi('plugin:fs|write_file', data, {
            headers: {
                path: encodeURIComponent(filePath),
                options: '{}',
            },
        });
    }

    async function removeTempUploadFile(filePath, invokeApi) {
        await invokeApi('plugin:fs|remove', { path: filePath });
    }

    function resolveUploadExtension({ preferredExtension, preferredName, sourceName }) {
        const candidates = [preferredExtension, preferredName, sourceName];

        for (const candidate of candidates) {
            const normalized = normalizeExtensionCandidate(candidate);
            if (normalized) {
                return normalized;
            }
        }

        return 'bin';
    }

    function normalizeExtensionCandidate(value) {
        if (typeof value !== 'string' || !value.trim()) {
            return null;
        }

        const cleaned = value.trim().toLowerCase().replace(/^\./, '');
        const extension = cleaned.includes('.') ? cleaned.split('.').pop() : cleaned;
        if (!extension) {
            return null;
        }

        return /^[a-z0-9]{1,12}$/.test(extension) ? extension : null;
    }

    function extractNativeFilePath(file) {
        if (!file || typeof file !== 'object') {
            return null;
        }

        const candidate = file.path || file.webkitRelativePath || null;
        if (!candidate || typeof candidate !== 'string') {
            return null;
        }

        if (candidate.toLowerCase().includes('fakepath')) {
            return null;
        }

        return candidate;
    }

    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    return {
        initialize,
        safeInvoke,
        normalizeCharacter,
        normalizeExtensions,
        getAllCharacters,
        resolveCharacterId,
        getSingleCharacter,
        ensureJsonl,
        stripJsonl,
        toFrontendChat,
        formatFileSize,
        parseTimestamp,
        exportChatAsText,
        exportChatAsJsonl,
        findAvatarByCharacterId,
        uniqueCharacterName,
        pickCharacterUpdateFields,
        createCharacterFromForm,
        editCharacterFromForm,
        uploadAvatarFromForm,
        materializeUploadFile,
    };
}
