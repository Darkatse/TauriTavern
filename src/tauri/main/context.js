export function createTauriMainContext({ invoke, convertFileSrc }) {
    const UPLOAD_CHUNK_BYTES = 4 * 1024 * 1024;
    let userDirectories = null;
    let characterCache = [];
    let characterByAvatar = new Map();
    let characterByDisplayName = new Map();
    let characterById = new Map();

    async function initialize() {
        await loadUserDirectories();
        installAssetPathHelpers();
    }

    async function loadUserDirectories() {
        let lastError = null;

        for (let attempt = 0; attempt < 40; attempt += 1) {
            try {
                userDirectories = await invoke('get_default_user_directory');
                return;
            } catch (error) {
                lastError = error;
                await sleep(250);
            }
        }

        console.warn('Could not load default user directories:', lastError);
    }

    function installAssetPathHelpers() {
        window.__TAURITAVERN_THUMBNAIL__ = (type, file, useTimestamp = false) => {
            const filePath = resolveAssetPath(type, file);

            if (filePath) {
                const assetUrl = toAssetUrl(filePath);
                if (assetUrl) {
                    return `${assetUrl}${useTimestamp ? `?t=${Date.now()}` : ''}`;
                }
            }

            return `/thumbnail?type=${encodeURIComponent(type)}&file=${encodeURIComponent(file)}${useTimestamp ? `&t=${Date.now()}` : ''}`;
        };

        window.__TAURITAVERN_BACKGROUND_PATH__ = (file) => {
            const filePath = resolveAssetPath('bg', file);
            const assetUrl = filePath ? toAssetUrl(filePath) : null;
            return assetUrl || `backgrounds/${encodeURIComponent(file)}`;
        };

        window.__TAURITAVERN_PERSONA_PATH__ = (file) => {
            const filePath = resolveAssetPath('persona', file);
            const assetUrl = filePath ? toAssetUrl(filePath) : null;
            return assetUrl || `User Avatars/${file}`;
        };

    }

    function resolveAssetPath(type, file) {
        if (!userDirectories || !file) {
            return null;
        }

        const cleanFile = sanitizeRelativePath(file);
        if (!cleanFile) {
            return null;
        }

        switch (type) {
            case 'avatar':
                return joinPath(userDirectories.characters, cleanFile);
            case 'persona':
                return joinPath(userDirectories.avatars, cleanFile);
            case 'bg':
                return joinPath(userDirectories.backgrounds, cleanFile);
            default:
                return null;
        }
    }

    function toAssetUrl(path) {
        if (!path) {
            return null;
        }

        if (typeof convertFileSrc === 'function') {
            try {
                // In Tauri WebView, file:// resources are generally blocked for img/src.
                // Always use the asset protocol URL generated by convertFileSrc.
                return convertFileSrc(path, 'asset');
            } catch (error) {
                console.warn('convertFileSrc failed:', error);
            }
        }

        return null;
    }

    function joinPath(base, child) {
        if (!base) {
            return null;
        }

        const normalizedBase = String(base).replace(/[\\/]+$/, '');
        const normalizedChild = String(child).replace(/^[\\/]+/, '');
        const separator = normalizedBase.includes('\\') ? '\\' : '/';

        return `${normalizedBase}${separator}${normalizedChild.replace(/[\\/]+/g, separator)}`;
    }

    function sanitizeRelativePath(file) {
        const decoded = decodeURIComponent(String(file));
        const normalized = decoded.replace(/[\\/]+/g, '/').replace(/^\/+/, '');

        if (!normalized || normalized.includes('..')) {
            return null;
        }

        return normalized;
    }

    async function safeInvoke(command, args = {}) {
        const invokeArgs = withTauriArgumentAliases(args);

        for (let attempt = 0; attempt < 20; attempt += 1) {
            try {
                return await invoke(command, invokeArgs);
            } catch (error) {
                const message = normalizeInvokeErrorMessage(error, `Command failed: ${command}`);
                if (attempt < 19 && shouldRetryInvoke(message)) {
                    await sleep(200);
                    continue;
                }
                throw new Error(message);
            }
        }
    }

    function withTauriArgumentAliases(args) {
        if (!args || typeof args !== 'object' || Array.isArray(args)) {
            return args;
        }

        const aliased = { ...args };

        for (const [key, value] of Object.entries(args)) {
            if (!key.includes('_')) {
                continue;
            }

            const camelCaseKey = key.replace(/_+([a-zA-Z0-9])/g, (_, char) => char.toUpperCase());
            if (!Object.prototype.hasOwnProperty.call(aliased, camelCaseKey)) {
                aliased[camelCaseKey] = value;
            }
        }

        return aliased;
    }

    function shouldRetryInvoke(message) {
        const normalized = String(message || '').toLowerCase();
        return (
            (normalized.includes('state') && normalized.includes('not managed')) ||
            normalized.includes('invoke is unavailable')
        );
    }

    function normalizeInvokeErrorMessage(error, fallback) {
        const extracted = extractErrorText(error);
        if (extracted && extracted !== '[object Object]') {
            return extracted;
        }

        try {
            const serialized = JSON.stringify(error);
            if (serialized && serialized !== '{}') {
                return serialized;
            }
        } catch {
            // Ignore serialization failure and continue fallback chain.
        }

        const stringified = String(error || '').trim();
        if (stringified && stringified !== '[object Object]') {
            return stringified;
        }

        return fallback;
    }

    function extractErrorText(value, depth = 0) {
        if (depth > 4 || value === null || value === undefined) {
            return '';
        }

        if (typeof value === 'string') {
            return value.trim();
        }

        if (typeof value === 'number' || typeof value === 'boolean') {
            return String(value);
        }

        if (value instanceof Error) {
            const nested = extractErrorText(value.message, depth + 1);
            return nested || String(value).trim();
        }

        if (Array.isArray(value)) {
            for (const item of value) {
                const nested = extractErrorText(item, depth + 1);
                if (nested) {
                    return nested;
                }
            }
            return '';
        }

        if (typeof value === 'object') {
            const keys = ['message', 'error', 'details', 'reason', 'cause', 'data'];
            for (const key of keys) {
                if (Object.prototype.hasOwnProperty.call(value, key)) {
                    const nested = extractErrorText(value[key], depth + 1);
                    if (nested) {
                        return nested;
                    }
                }
            }
        }

        return '';
    }

    function normalizeCharacter(character) {
        if (!character || typeof character !== 'object') {
            return character;
        }

        const extensions = normalizeExtensions(character.extensions);

        if (!Object.prototype.hasOwnProperty.call(extensions, 'talkativeness')) {
            extensions.talkativeness = Number(character.talkativeness ?? 0.5);
        }

        if (!Object.prototype.hasOwnProperty.call(extensions, 'fav')) {
            extensions.fav = Boolean(character.fav);
        }

        const characterBook = Object.prototype.hasOwnProperty.call(character, 'character_book')
            ? character.character_book
            : character?.data?.character_book;

        const name = pickCharacterTextValue(character.name, character?.data?.name);
        const description = pickCharacterTextValue(character.description, character?.data?.description);
        const personality = pickCharacterTextValue(character.personality, character?.data?.personality);
        const scenario = pickCharacterTextValue(character.scenario, character?.data?.scenario);
        const firstMes = pickCharacterTextValue(character.first_mes, character?.data?.first_mes);
        const mesExample = pickCharacterTextValue(character.mes_example, character?.data?.mes_example);
        const creator = pickCharacterTextValue(character.creator, character?.data?.creator);
        const creatorNotes = pickCharacterTextValue(character.creator_notes, character?.data?.creator_notes);
        const characterVersion = pickCharacterTextValue(character.character_version, character?.data?.character_version);
        const systemPrompt = pickCharacterTextValue(character.system_prompt, character?.data?.system_prompt);
        const postHistoryInstructions = pickCharacterTextValue(
            character.post_history_instructions,
            character?.data?.post_history_instructions,
        );

        const data = {
            name,
            description,
            personality,
            scenario,
            first_mes: firstMes,
            mes_example: mesExample,
            creator,
            creator_notes: creatorNotes,
            character_version: characterVersion,
            system_prompt: systemPrompt,
            post_history_instructions: postHistoryInstructions,
            tags: Array.isArray(character.tags) ? character.tags : [],
            alternate_greetings: Array.isArray(character.alternate_greetings) ? character.alternate_greetings : [],
            character_book: characterBook ?? null,
            extensions,
        };

        return {
            ...character,
            name,
            description,
            personality,
            scenario,
            first_mes: firstMes,
            mes_example: mesExample,
            creator,
            creator_notes: creatorNotes,
            character_version: characterVersion,
            system_prompt: systemPrompt,
            post_history_instructions: postHistoryInstructions,
            creatorcomment: creatorNotes,
            data,
            shallow: false,
        };
    }

    function pickCharacterTextValue(...values) {
        for (const value of values) {
            if (typeof value === 'string' && value.length > 0) {
                return value;
            }
        }

        return '';
    }

    function normalizeExtensions(input) {
        if (!input || typeof input !== 'object' || Array.isArray(input)) {
            return {};
        }

        return { ...input };
    }

    function updateCharacterCache(characters) {
        characterCache = Array.isArray(characters) ? characters : [];
        characterByAvatar = new Map();
        characterByDisplayName = new Map();
        characterById = new Map();

        for (const character of characterCache) {
            if (character?.avatar) {
                const rawAvatar = String(character.avatar);
                characterByAvatar.set(rawAvatar, character);

                const normalizedAvatar = normalizeAvatarFileName(rawAvatar);
                if (normalizedAvatar) {
                    characterByAvatar.set(normalizedAvatar, character);
                }
            }

            if (character?.name) {
                characterByDisplayName.set(String(character.name), character);
            }

            const characterId = getCharacterId(character);
            if (characterId) {
                characterById.set(characterId, character);
            }
        }
    }

    async function getAllCharacters({ shallow = false, forceRefresh = false } = {}) {
        if (!forceRefresh && characterCache.length > 0) {
            return characterCache;
        }

        const characters = await safeInvoke('get_all_characters', { shallow });
        const normalized = Array.isArray(characters) ? characters.map(normalizeCharacter) : [];
        updateCharacterCache(normalized);
        return normalized;
    }

    async function resolveCharacterId({ avatar, fallbackName } = {}) {
        const avatarInternalId = getAvatarInternalId(avatar);
        const avatarFileName = normalizeAvatarFileName(avatar);

        const resolveFromCache = () => {
            if (avatar !== undefined && avatar !== null) {
                const fromRawAvatar = characterByAvatar.get(String(avatar));
                const fromRawAvatarId = getCharacterId(fromRawAvatar);
                if (fromRawAvatarId) {
                    return fromRawAvatarId;
                }
            }

            if (avatarFileName) {
                const fromFileName = characterByAvatar.get(avatarFileName);
                const fromFileNameId = getCharacterId(fromFileName);
                if (fromFileNameId) {
                    return fromFileNameId;
                }
            }

            if (avatarInternalId) {
                const fromInternalId = characterById.get(avatarInternalId);
                const fromInternalIdValue = getCharacterId(fromInternalId);
                if (fromInternalIdValue) {
                    return fromInternalIdValue;
                }
            }

            return null;
        };

        if (avatarInternalId || avatarFileName) {
            const cached = resolveFromCache();
            if (cached) {
                return cached;
            }

            await getAllCharacters({ shallow: false });
            const refreshed = resolveFromCache();
            if (refreshed) {
                return refreshed;
            }

            // Follow SillyTavern behavior: avatar stem defines chat directory key.
            if (avatarInternalId) {
                return avatarInternalId;
            }
        }

        const fallback = String(fallbackName || '').trim();
        if (!fallback) {
            return null;
        }

        const cachedByName = characterByDisplayName.get(fallback);
        const cachedByNameId = getCharacterId(cachedByName);
        if (cachedByNameId) {
            return cachedByNameId;
        }

        const cachedByInternalId = characterById.get(fallback);
        const cachedByInternalIdValue = getCharacterId(cachedByInternalId);
        if (cachedByInternalIdValue) {
            return cachedByInternalIdValue;
        }

        await getAllCharacters({ shallow: false });
        const refreshedByName = characterByDisplayName.get(fallback);
        const refreshedByNameId = getCharacterId(refreshedByName);
        if (refreshedByNameId) {
            return refreshedByNameId;
        }

        const refreshedByInternalId = characterById.get(fallback);
        const refreshedByInternalIdValue = getCharacterId(refreshedByInternalId);
        if (refreshedByInternalIdValue) {
            return refreshedByInternalIdValue;
        }

        return fallback;
    }

    function normalizeAvatarFileName(avatar) {
        if (avatar === null || avatar === undefined) {
            return null;
        }

        let value = String(avatar).trim();
        if (!value) {
            return null;
        }

        if (value.includes('?')) {
            try {
                const parsed = new URL(value, 'http://localhost');
                value = parsed.searchParams.get('file') || parsed.pathname || value;
            } catch {
                // Keep original value when URL parsing fails.
            }
        }

        try {
            value = decodeURIComponent(value);
        } catch {
            // Keep original value when decodeURIComponent fails.
        }

        value = value.split('?')[0].split('#')[0];
        if (!value) {
            return null;
        }

        const normalized = value.replace(/[\\/]+/g, '/');
        const fileName = normalized.split('/').pop();
        return fileName || null;
    }

    function getAvatarInternalId(avatar) {
        const fileName = normalizeAvatarFileName(avatar);
        if (!fileName) {
            return null;
        }

        return fileName.replace(/\.[^/.]+$/, '') || null;
    }

    function getCharacterId(character) {
        if (!character || typeof character !== 'object') {
            return null;
        }

        const fromAvatar = getAvatarInternalId(character.avatar);
        if (fromAvatar) {
            return fromAvatar;
        }

        if (character.name) {
            return String(character.name);
        }

        return null;
    }

    async function getSingleCharacter(body) {
        const explicitName = body?.name || body?.ch_name;
        const avatar = body?.avatar_url || body?.avatar;
        const characterId = await resolveCharacterId({ avatar, fallbackName: explicitName });

        if (!characterId) {
            return null;
        }

        const character = await safeInvoke('get_character', { name: characterId });
        const normalized = normalizeCharacter(character);
        if (normalized?.avatar) {
            characterByAvatar.set(String(normalized.avatar), normalized);
        }
        if (normalized?.name) {
            characterByDisplayName.set(String(normalized.name), normalized);
        }
        const normalizedCharacterId = getCharacterId(normalized);
        if (normalizedCharacterId) {
            characterById.set(normalizedCharacterId, normalized);
        }
        return normalized;
    }

    function ensureJsonl(fileName) {
        const value = String(fileName || '');
        if (!value) {
            return value;
        }

        return value.endsWith('.jsonl') ? value : `${value}.jsonl`;
    }

    function stripJsonl(fileName) {
        const value = String(fileName || '').trim();
        if (!value) {
            return '';
        }

        return value.replace(/\.jsonl$/i, '');
    }

    function toFrontendChat(chatDto) {
        if (Array.isArray(chatDto)) {
            return chatDto.map((entry) => (entry && typeof entry === 'object' ? { ...entry } : entry));
        }

        const messages = Array.isArray(chatDto?.messages)
            ? chatDto.messages.map((message) => {
                const messageAdditional = message?.additional && typeof message.additional === 'object'
                    ? message.additional
                    : {};
                const rawExtra = message?.extra && typeof message.extra === 'object' ? message.extra : {};
                const extraAdditional = rawExtra?.additional && typeof rawExtra.additional === 'object'
                    ? rawExtra.additional
                    : {};
                const extra = { ...rawExtra, ...extraAdditional };
                delete extra.additional;

                return {
                    ...messageAdditional,
                    name: message.name,
                    is_user: Boolean(message.is_user),
                    is_system: Boolean(message.is_system),
                    send_date: message.send_date,
                    mes: message.mes,
                    extra,
                };
            })
            : [];

        const metadata = chatDto?.chat_metadata && typeof chatDto.chat_metadata === 'object'
            ? chatDto.chat_metadata
            : { chat_id_hash: Number(chatDto?.chat_id || 0) };

        const header = {
            user_name: chatDto?.user_name || 'User',
            character_name: chatDto?.character_name || '',
            create_date: chatDto?.create_date || '',
            chat_metadata: metadata,
        };

        return [header, ...messages];
    }

    function formatFileSize(value) {
        const size = Number(value || 0);
        if (!Number.isFinite(size) || size <= 0) {
            return '0 B';
        }

        const units = ['B', 'KB', 'MB', 'GB'];
        let unitIndex = 0;
        let result = size;

        while (result >= 1024 && unitIndex < units.length - 1) {
            result /= 1024;
            unitIndex += 1;
        }

        return `${result.toFixed(result >= 10 ? 0 : 1)} ${units[unitIndex]}`;
    }

    function normalizeEpochMillis(epoch) {
        if (!Number.isFinite(epoch)) {
            return 0;
        }

        const normalized = Math.trunc(epoch);
        return Math.abs(normalized) < 1_000_000_000_000 ? normalized * 1000 : normalized;
    }

    function parseTimestamp(sendDate) {
        if (typeof sendDate === 'number') {
            return normalizeEpochMillis(sendDate);
        }

        const raw = String(sendDate || '').trim();
        if (!raw) {
            return 0;
        }

        if (/^-?\d+(\.\d+)?$/.test(raw)) {
            return normalizeEpochMillis(Number(raw));
        }

        const parsed = Date.parse(raw);
        return Number.isFinite(parsed) ? parsed : 0;
    }

    function exportChatAsText(frontendChat) {
        const payload = Array.isArray(frontendChat) ? frontendChat : [];
        const lines = payload
            .slice(1)
            .filter((message) => !Boolean(message?.is_system))
            .map((message) => {
                const role = message?.name || (message?.is_user ? 'User' : 'Assistant');
                const displayText = message?.extra?.display_text || message?.mes || '';
                return `${role}: ${String(displayText).replace(/\r?\n/g, '\n')}`;
            });

        return lines.join('\n\n');
    }

    function exportChatAsJsonl(frontendChat) {
        return frontendChat.map((item) => JSON.stringify(item)).join('\n');
    }

    function findAvatarByCharacterId(characterId) {
        const key = String(characterId || '').trim();
        if (!key) {
            return '';
        }

        const byDisplayName = characterByDisplayName.get(key);
        if (byDisplayName?.avatar) {
            return byDisplayName.avatar;
        }

        const byInternalId = characterById.get(key);
        if (byInternalId?.avatar) {
            return byInternalId.avatar;
        }

        const normalizedAvatar = normalizeAvatarFileName(key);
        if (normalizedAvatar) {
            const byAvatar = characterByAvatar.get(normalizedAvatar);
            if (byAvatar?.avatar) {
                return byAvatar.avatar;
            }

            if (normalizedAvatar.toLowerCase().endsWith('.png')) {
                return normalizedAvatar;
            }

            const pngName = `${normalizedAvatar}.png`;
            const byPng = characterByAvatar.get(pngName);
            if (byPng?.avatar) {
                return byPng.avatar;
            }

            return pngName;
        }

        return '';
    }

    async function uniqueCharacterName(baseName) {
        await getAllCharacters({ shallow: false });

        if (!characterByDisplayName.has(baseName)) {
            return baseName;
        }

        let index = 2;
        while (characterByDisplayName.has(`${baseName} ${index}`)) {
            index += 1;
        }

        return `${baseName} ${index}`;
    }

    function boolFromForm(formData, key) {
        const raw = formData.get(key);
        if (raw === null || raw === undefined) {
            return false;
        }

        const value = String(raw).trim().toLowerCase();
        return value === 'true' || value === '1' || value === 'on' || value === 'yes';
    }

    function numberFromForm(formData, key, fallback) {
        const raw = formData.get(key);
        const value = Number(raw);
        return Number.isFinite(value) ? value : fallback;
    }

    function stringFromForm(formData, key, fallback = '') {
        const raw = formData.get(key);
        if (raw === null || raw === undefined) {
            return fallback;
        }

        return String(raw);
    }

    function splitTags(tagsRaw) {
        if (Array.isArray(tagsRaw)) {
            return tagsRaw.map((tag) => String(tag).trim()).filter(Boolean);
        }

        if (typeof tagsRaw === 'string') {
            return tagsRaw.split(',').map((tag) => tag.trim()).filter(Boolean);
        }

        return [];
    }

    function parseJsonSafe(value, fallback = {}) {
        if (typeof value !== 'string' || !value.trim()) {
            return fallback;
        }

        try {
            return JSON.parse(value);
        } catch {
            return fallback;
        }
    }

    function buildCharacterExtensions(formData) {
        const extensions = parseJsonSafe(stringFromForm(formData, 'extensions', ''), {});

        const world = stringFromForm(formData, 'world', '').trim();
        if (world) {
            extensions.world = world;
        }

        const depthPrompt = stringFromForm(formData, 'depth_prompt_prompt', '').trim();
        if (depthPrompt) {
            extensions.depth_prompt = {
                prompt: depthPrompt,
                depth: numberFromForm(formData, 'depth_prompt_depth', 4),
                role: stringFromForm(formData, 'depth_prompt_role', 'system'),
            };
        }

        extensions.talkativeness = numberFromForm(formData, 'talkativeness', 0.5);
        extensions.fav = boolFromForm(formData, 'fav');

        return extensions;
    }

    function formDataToCreateCharacterDto(formData) {
        return {
            name: stringFromForm(formData, 'ch_name', '').trim(),
            description: stringFromForm(formData, 'description', ''),
            personality: stringFromForm(formData, 'personality', ''),
            scenario: stringFromForm(formData, 'scenario', ''),
            first_mes: stringFromForm(formData, 'first_mes', ''),
            mes_example: stringFromForm(formData, 'mes_example', ''),
            creator: stringFromForm(formData, 'creator', ''),
            creator_notes: stringFromForm(formData, 'creator_notes', ''),
            character_version: stringFromForm(formData, 'character_version', ''),
            tags: splitTags(stringFromForm(formData, 'tags', '')),
            talkativeness: numberFromForm(formData, 'talkativeness', 0.5),
            fav: boolFromForm(formData, 'fav'),
            alternate_greetings: formData.getAll('alternate_greetings').map((item) => String(item)).filter(Boolean),
            system_prompt: stringFromForm(formData, 'system_prompt', ''),
            post_history_instructions: stringFromForm(formData, 'post_history_instructions', ''),
            extensions: buildCharacterExtensions(formData),
        };
    }

    function formDataToUpdateCharacterDto(formData) {
        const dto = formDataToCreateCharacterDto(formData);
        const chat = stringFromForm(formData, 'chat', '').trim();

        return {
            name: dto.name,
            chat: chat || undefined,
            description: dto.description,
            personality: dto.personality,
            scenario: dto.scenario,
            first_mes: dto.first_mes,
            mes_example: dto.mes_example,
            creator: dto.creator,
            creator_notes: dto.creator_notes,
            character_version: dto.character_version,
            tags: dto.tags,
            talkativeness: dto.talkativeness,
            fav: dto.fav,
            alternate_greetings: dto.alternate_greetings,
            system_prompt: dto.system_prompt,
            post_history_instructions: dto.post_history_instructions,
            extensions: dto.extensions,
        };
    }

    async function createCharacterFromForm(formData, requestUrl) {
        const dto = formDataToCreateCharacterDto(formData);
        const crop = parseCropParam(requestUrl);
        const file = formData.get('avatar');

        if (file instanceof Blob && file.size > 0) {
            const fileInfo = await materializeUploadFile(file, {
                preferredName: file.name,
            });
            if (!fileInfo?.filePath) {
                const reason = fileInfo?.error ? `: ${fileInfo.error}` : '';
                throw new Error(`Unable to access avatar file path${reason}`);
            }

            try {
                return await safeInvoke('create_character_with_avatar', {
                    dto: {
                        character: dto,
                        avatar_path: fileInfo.filePath,
                        crop,
                    },
                });
            } finally {
                await fileInfo.cleanup?.();
            }
        }

        return safeInvoke('create_character', { dto });
    }

    async function editCharacterFromForm(formData, requestUrl) {
        const avatar = stringFromForm(formData, 'avatar_url', '');
        const fallbackName = stringFromForm(formData, 'ch_name', '');
        const originalCharacterId = await resolveCharacterId({ avatar, fallbackName });

        if (!originalCharacterId) {
            throw new Error('Character not found for edit');
        }

        const dto = formDataToUpdateCharacterDto(formData);
        await safeInvoke('update_character', { name: originalCharacterId, dto });

        const file = formData.get('avatar');
        if (file instanceof Blob && file.size > 0) {
            const crop = parseCropParam(requestUrl);
            const fileInfo = await materializeUploadFile(file, {
                preferredName: file.name,
            });

            if (!fileInfo?.filePath) {
                const reason = fileInfo?.error ? `: ${fileInfo.error}` : '';
                throw new Error(`Unable to access avatar file path${reason}`);
            }

            try {
                await safeInvoke('update_avatar', {
                    dto: {
                        name: dto.name || originalCharacterId,
                        avatar_path: fileInfo.filePath,
                        crop,
                    },
                });
            } finally {
                await fileInfo.cleanup?.();
            }
        }
    }

    function parseCropParam(url) {
        const raw = url.searchParams.get('crop');
        if (!raw) {
            return null;
        }

        try {
            return JSON.parse(raw);
        } catch {
            return null;
        }
    }

    function pickCharacterUpdateFields(payload) {
        const dto = {};
        const keys = [
            'name',
            'chat',
            'description',
            'personality',
            'scenario',
            'first_mes',
            'mes_example',
            'creator',
            'creator_notes',
            'character_version',
            'tags',
            'talkativeness',
            'fav',
            'alternate_greetings',
            'system_prompt',
            'post_history_instructions',
            'extensions',
        ];

        for (const key of keys) {
            if (Object.prototype.hasOwnProperty.call(payload, key)) {
                dto[key] = payload[key];
            }
        }

        return dto;
    }

    async function uploadAvatarFromForm(formData, requestUrl) {
        const file = formData.get('avatar');
        if (!(file instanceof Blob)) {
            throw new Error('No avatar file provided');
        }

        const overwriteNameRaw = formData.get('overwrite_name');
        const overwriteName = overwriteNameRaw ? String(overwriteNameRaw) : null;
        const crop = parseCropParam(requestUrl);

        const fileInfo = await materializeUploadFile(file, {
            preferredName: file.name,
        });
        if (!fileInfo?.filePath) {
            const reason = fileInfo?.error ? `: ${fileInfo.error}` : '';
            throw new Error(`Unable to access avatar file path${reason}`);
        }

        try {
            return await safeInvoke('upload_avatar', {
                file_path: fileInfo.filePath,
                overwrite_name: overwriteName,
                crop: crop ? JSON.stringify(crop) : null,
            });
        } finally {
            await fileInfo.cleanup?.();
        }
    }

    async function materializeUploadFile(file, { preferredName = '', preferredExtension = '' } = {}) {
        if (!(file instanceof Blob)) {
            return null;
        }

        const directPath = extractNativeFilePath(file);
        if (shouldUseDirectUploadPath(directPath)) {
            return {
                filePath: directPath,
                isTemporary: false,
            };
        }

        const tauri = window.__TAURI__;
        const pathApi = tauri?.path;
        const invokeApi = tauri?.core?.invoke;
        if (typeof pathApi?.join !== 'function') {
            return {
                filePath: '',
                error: 'Tauri path API is unavailable',
            };
        }

        if (typeof invokeApi !== 'function') {
            return {
                filePath: '',
                error: 'Tauri invoke API is unavailable',
            };
        }

        const extension = resolveUploadExtension({
            preferredExtension,
            preferredName,
            sourceName: file.name,
        });
        const fileName = `tauritavern-upload-${Date.now()}-${Math.random().toString(16).slice(2)}.${extension}`;

        try {
            const uploadDir = await resolveUploadDirectory(pathApi);
            const filePath = await pathApi.join(uploadDir, fileName);
            await writeTempUploadFile(filePath, file, invokeApi);

            return {
                filePath,
                isTemporary: true,
                cleanup: async () => {
                    try {
                        await removeTempUploadFile(filePath, invokeApi);
                    } catch {
                        // noop
                    }
                },
            };
        } catch (error) {
            console.warn('Tauri temp file write failed:', error);
            return {
                filePath: '',
                error: error?.message || 'Failed to materialize upload file',
                isTemporary: false,
            };
        }
    }

    async function resolveUploadDirectory(pathApi) {
        const getAppCacheDir = typeof pathApi?.appCacheDir === 'function'
            ? () => pathApi.appCacheDir()
            : null;
        const getTempDir = typeof pathApi?.tempDir === 'function'
            ? () => pathApi.tempDir()
            : null;

        const candidates = [];
        if (isAndroidRuntime() && getAppCacheDir) {
            candidates.push(getAppCacheDir);
        }

        if (getTempDir) {
            candidates.push(getTempDir);
        }

        if (getAppCacheDir && !candidates.includes(getAppCacheDir)) {
            candidates.push(getAppCacheDir);
        }

        let lastError = null;
        for (const candidate of candidates) {
            try {
                const directory = await candidate();
                if (typeof directory === 'string' && directory.trim()) {
                    return directory;
                }
            } catch (error) {
                lastError = error;
            }
        }

        if (lastError) {
            throw lastError;
        }

        throw new Error('No writable upload directory is available');
    }

    function shouldUseDirectUploadPath(filePath) {
        if (!isLikelyFileSystemPath(filePath)) {
            return false;
        }

        // Android file pickers often expose content URIs or external paths that are not directly readable by Rust.
        // Materializing into app storage keeps behavior consistent and permission-safe.
        if (isAndroidRuntime()) {
            return false;
        }

        return true;
    }

    function isLikelyFileSystemPath(value) {
        if (typeof value !== 'string' || !value.trim()) {
            return false;
        }

        const normalized = value.trim();
        if (/^[a-z]+:\/\//i.test(normalized)) {
            return false;
        }

        return (
            normalized.startsWith('/') ||
            normalized.startsWith('\\\\') ||
            /^[a-z]:[\\/]/i.test(normalized)
        );
    }

    function isAndroidRuntime() {
        if (typeof navigator === 'undefined' || typeof navigator.userAgent !== 'string') {
            return false;
        }

        return /android/i.test(navigator.userAgent);
    }

    async function writeTempUploadFile(filePath, file, invokeApi) {
        if (typeof file?.stream === 'function' && typeof ReadableStream !== 'undefined') {
            try {
                const { writeFile } = await import('@tauri-apps/plugin-fs');
                await writeFile(filePath, file.stream(), {
                    create: true,
                    truncate: true,
                });
                return;
            } catch (error) {
                console.warn('Streamed temp file write failed; falling back to chunked write:', error);
            }
        }

        await writeTempUploadFileChunked(filePath, file, invokeApi);
    }

    async function writeTempUploadFileChunked(filePath, file, invokeApi) {
        let offset = 0;
        let append = false;

        if (file.size === 0) {
            await invokeApi('plugin:fs|write_file', new Uint8Array(0), {
                headers: {
                    path: encodeURIComponent(filePath),
                    options: JSON.stringify({ append: false, create: true }),
                },
            });
            return;
        }

        while (offset < file.size) {
            const end = Math.min(offset + UPLOAD_CHUNK_BYTES, file.size);
            const chunk = file.slice(offset, end);
            const bytes = new Uint8Array(await chunk.arrayBuffer());

            await invokeApi('plugin:fs|write_file', bytes, {
                headers: {
                    path: encodeURIComponent(filePath),
                    options: JSON.stringify({ append, create: true }),
                },
            });

            offset = end;
            append = true;
        }
    }

    async function removeTempUploadFile(filePath, invokeApi) {
        await invokeApi('plugin:fs|remove', { path: filePath });
    }

    function resolveUploadExtension({ preferredExtension, preferredName, sourceName }) {
        const candidates = [preferredExtension, preferredName, sourceName];

        for (const candidate of candidates) {
            const normalized = normalizeExtensionCandidate(candidate);
            if (normalized) {
                return normalized;
            }
        }

        return 'bin';
    }

    function normalizeExtensionCandidate(value) {
        if (typeof value !== 'string' || !value.trim()) {
            return null;
        }

        const cleaned = value.trim().toLowerCase().replace(/^\./, '');
        const extension = cleaned.includes('.') ? cleaned.split('.').pop() : cleaned;
        if (!extension) {
            return null;
        }

        return /^[a-z0-9]{1,12}$/.test(extension) ? extension : null;
    }

    function extractNativeFilePath(file) {
        if (!file || typeof file !== 'object') {
            return null;
        }

        const candidate = file.path || file.webkitRelativePath || null;
        if (!candidate || typeof candidate !== 'string') {
            return null;
        }

        if (candidate.toLowerCase().includes('fakepath')) {
            return null;
        }

        return candidate;
    }

    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }

    return {
        initialize,
        safeInvoke,
        normalizeCharacter,
        normalizeExtensions,
        getAllCharacters,
        resolveCharacterId,
        getSingleCharacter,
        ensureJsonl,
        stripJsonl,
        toFrontendChat,
        formatFileSize,
        parseTimestamp,
        exportChatAsText,
        exportChatAsJsonl,
        findAvatarByCharacterId,
        uniqueCharacterName,
        pickCharacterUpdateFields,
        createCharacterFromForm,
        editCharacterFromForm,
        uploadAvatarFromForm,
        materializeUploadFile,
        toAssetUrl,
    };
}
